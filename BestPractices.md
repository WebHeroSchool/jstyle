#Лучшие практики JavaScript

### 1.Избегайте использования глобальных переменных

Поскольку интерпретатор просматривает область видимости по ссылке на глобальные переменные из функции или другой области, глобальная переменная будет неактуальна при потере локальной области. Если глобальные переменные не будут сохраняться в течение всего времени выполнения скрипта, производительность будет улучшена. Лучше используйте локальные переменные и учитесь использовать замыкание.

### 2.Приоритет локальных переменных

Интерпретатор JavaScript сразу ищет переменные локально, потом постепенно повышает уровень области видимости до глобальных переменных. Сохраняя переменные в локальной области видимости, вы получаете к ним доступ гораздо быстрее.

Локальные переменные берутся из ближайшего контекста, и могут проходить несколько уровней вплоть до глобальных запросов. При определении области видимости функции в локальных переменных, если они раньше не объявлялись, важно использовать ключевые слова let или const. Это позволит определить текущую область, что сократит поиск и ускорит код.

### 3.Декларирование в верху области видимости

Хорошей практикой программирования на JavaScript является практика размещения всех деклараций в верху скрипта или функции.

Это позволит:

+получить более чистый код
+обеспечить единое место для отслеживания локальных переменных
+избегать нежелательных (неявных) глобальных переменных
+снизить вероятность появления нежелательных повторных деклараций

```js
// Декларируем в начале
var firstName, lastName, price, discount, fullPrice;
// Используем потом
firstName = "John";
lastName = "Doe";
price = 19.90;
discount = 0.10;
fullPrice = price * 100 / discount;
```
Это также относится и к переменным цикла:

```js
// Декларируем в начале
var i;
// Используем потом
for (i = 0; i < 5; i++) {
```
### 4.Инициализируйте переменные
По хорошему всегда следует инициализировать переменные во время их декларации.
Это позволит:
+получить более чистый код
+обеспечить единое место для инициализации переменных
+избежать неопределенных значений
```js
// Декларируем и инициализируем в начале
var firstName = "",
    lastName = "",
    price = 0,
    discount = 0,
    fullPrice = 0,
    myArray = [],
    myObject = {};
````
### 5.Никогда не декларируйте объекты Number, String, Boolean
С числами, строками и логическими значениями всегда обращайтесь как к примитивам, а не объектам.
Декларирование этих типов как объектов замедляет скорость выполнения скрипта и приводит к неприятным побочным эффектам:
```js
 var x = "John";             
 var y = new String("John");
 (x === y) // возвращает false, так как x — строка, а y — объект
```
Или даже хуже:
```js
 var x = new String("John");             
 var y = new String("John");
 (x == y) // возвращает false, так как нельзя сравнивать объекты
```
### 6.Не используйте команду new Object()
+Используйте { } вместо new Object()
+Используйте "" вместо new String()
+Используйте 0 вместо new Number()
+Используйте false вместо new Boolean()
+Используйте [ ] вместо new Array()
+Используйте /()/ вместо new RegExp()
+Используйте function (){ } вместо new Function()
```js
 var x1 = {};           // новый объект
 var x2 = "";           // новая строка
 var x3 = 0;            // новое число
 var x4 = false;        // новое значение boolean
 var x5 = [];           // новый объект массива
 var x6 = /()/;         // новое регулярное выражение
 var x7 = function(){}; // новый объект функции
```
### 7.Помните об автоматическом преобразовании типов
Помните о том, что числа могут быть случайно преобразованы в строки или значение NaN (Не число).
JavaScript — слабо типизированный язык программирования. Переменные могут содержать значения разных типов, при этом переменные могут менять тип, содержащихся в них данных:
```js
 var x = "Hello";     // typeof x — строка
 x = 5;               // изменяем тип, теперь typeof x — число
```
Во время математических операций JavaScript может преобразовывать числа в строки:
```js
 var x = 5 + 7;       // x.valueOf() возвращает 12,  typeof x — число
 var x = 5 + "7";     // x.valueOf() возвращает 57,  typeof x — строка
 var x = "5" + 7;     // x.valueOf() возвращает 57,  typeof x — строка
 var x = 5 - 7;       // x.valueOf() возвращает -2,  typeof x — число
 var x = 5 - "7";     // x.valueOf() возвращает -2,  typeof x — число
 var x = "5" - 7;     // x.valueOf() возвращает -2,  typeof x — число
 var x = 5 - "x";     // x.valueOf() возвращает NaN, typeof x — число
```
Вычитание строки из строки не генерирует ошибку, а возвращает значение NaN (Не число):
```js
 "Hello" - "Dolly"    // возвращает NaN
```
### 8.Используйте сравнение ===
Оператор сравнения == всегда приводит сравниваемые значения к одинаковым типам.
Оператор сравнения === сравнивает как сами значения, так и их типы:
```js
 0 == "";        // true
 1 == "1";       // true
 1 == true;      // true
 0 === "";       // false
 1 === "1";      // false
 1 === true;     // false
```
### 9.Используйте параметры по умолчанию
Если функция вызывается с пропущенным параметром, то этому параметру присваивается значение undefined.
Значения undefined могут сломать ваш код. Если взять за правило присваивать параметрам значения по умолчанию, то это будет хорошей привычкой.
```js
 function myFunction(x, y) {
     if (y === undefined) {
         y = 0;
     }
 } 
```
### 10.Всегда заканчивайте выражение switch оператором default
Всегда заканчивайте выражение switch оператором default. Даже если вы думаете, что он совсем не нужен.
```js
 switch (new Date().getDay()) {
     case 0:
         day = "Воскресенье";
         break;
     case 1:
         day = "Понедельник";
         break;
     case 2:
         day = "Вторник";
         break;
     case 3:
         day = "Среда";
         break;
     case 4:
         day = "Четверг";
         break;
     case 5:
         day = "Пятница";
         break;
     case 6:
         day = "Суббота";
         break;
     default:
        day = "Неизвестно";
} 
```
### 11.Старайтесь не использовать eval()
Функция eval() используется, чтобы запустить текст, как код. Почти во всех случаях в этом нет необходимости.
Из-за того, что эта функция позволяет запускать самостоятельный код, она еще может являться и источником проблем безопасности.